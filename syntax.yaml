operators:
 # defines syntax for recursive-regex and/or operator-precedence grammar
 # in descending precedence

 - "[ ]"
 - '" "'

 - < where
 - ~ but
# - ~ as ~

 - :=
 - :-
 - "="
 - ["<", ">"]
 - ":"
 - "~"
 - v

 - [<-, ->]
 - [<--, -->]
 - [=>, ==>]
 - [<=, <==]
 - [<~, ~>]

 - "{ }"

 - [., .]
 - ","

 - ( )

 - ++
 - --

 - src
 - has

 - ==
 - ["+", "+"]
 - "-"
 - ["*", "/"]
 - ^


min_spaces:
 __default__: 1

 ( )   : 0
 "[ ]" : 0
 "{ }" : 0

 +   : 0
 "-" : 0
 "*" : 0
 /   : 0
 ^   : 0


order:
 # sort lines by operator to show note

 - :=
 - :-
 - "="

 - <
 - ">"
 - < where
 - ":"

 - "~"
 - ~ but

 - ->
 - <-
 - ~>
 - <~
 - <--
 - -->
 - =>
 - <=
 - ==>
 - <==


# e.g. left chaining
#  x , y , z
#  (x , y) , z
#  x , z
#  x

reduce:
 __default__: right

 # head operators

 ","     : left

 :=      : left
 :-      : left
 "="     : left
 "~"     : left

 ":"     : left
 "<"     : left
 ">"     : left

 < where : left
 ~ but   : left

 +       : join
 "-"     : join
 "*"     : join
 /       : join
 .       : join


tokens:
 # [{token: [verbose regex]}]
 # these regexes capture a line as an operand, keeping 0-space opeartors from wrongly parsing them

 - url:
    - |
      ((?P<scheme>https?|ftp):\/)?
      \/?
      ((?P<username>.*?)(:(?P<password>.*?)|)@)?
      (?P<hostname>([^:\/\s]+\.)+[^:\/\s]+)
      (?P<port>:([^\/]*))?
      (?P<path>(\/\w+)*\/)
      (?P<filename>[-\w.]+[^#?\s]*)?
      (?P<query>\?([^#]*))?
      (?P<fragment>#(.*))?

 - word:
    - not: |
           ([0-9]*?[\.\,]?[0-9]+?)
           ([\-+*/]([0-9]*?[\.\,]?[0-9]+?)+?)+?

    - |
      ([\-.+_/]?)?
      (\w+?[\-.+_/]+?)+
      (\w+)?

 - percent:
    - (?P<n>\w+)%

parsers:
 - ellipsis: (^|\s)(\.\.\.)($|\s)
 - comment: ^\w*\.
 - default: .*
