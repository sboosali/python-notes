verbs:
 # mapping from concrete syntax (operators as config strings) to abstract syntax (relations as python classes)
 # maps "operators" to "verbs"
 ""      : text
 ~       : edge
 ","     : alias
 ":"     : is_a
 "<"     : subset
 +       : plus # [plus, more]
 ->      : causes
 <-      : is_caused_by
 ==>     : becomes
 <==     : comes_from
 =>      : goes_to
 <=      : went_from
 â‰ˆ       : similar
 .       : and
 /       : and
 < where : subset_where

default_verb: edge

chaining:
 # e.g. left chaining
 #  x , y , z
 #  (x , y) , z
 #  x , z
 #  x
 ","  : left
 ":"  : left

default_chain: right

opposites:
# or will you trip over your bootstraps into the rabbit hole of defining the properties of the semantics within the syntax itself?
# "opposite" is a relation, naturally an edge. the edges "->" and "<-" should have the "opposites" edge between them.

properties:
 # with graphical interpretation
 - symmetric #: directed => undirected
 - transitive #: in/out edge => path to/from

relations:
 # nice abuse of notation with colon

 related: symmetric
 similar: symmetric

 iff: symmetric, transitive
 equals: symmetric, transitive

 causes: transitive
 implies: transitive
 subset: transitive

 alias: transitive
