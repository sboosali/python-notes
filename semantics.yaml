edges:
 # mapping from concrete syntax (operators as config strings) to abstract syntax (relations as python classes)
 # maps "verbs" to "edges"
 __default__: ""

 ""      : ""

 =       : equals
 :=      : defined_as
 ~       : edge
 ":"     : is_a
 "<"     : subset
 â‰ˆ       : similar
 < where : subset_where

 +       : plus # [plus, more]
 "-"     : minus
 "*"     : times
 /       : divide

 ->      : causes
 <-      : is_caused_by
 ==>     : becomes
 <==     : comes_from
 =>      : goes_to
 <=      : went_from

 .       : and
 ","     : alias
 has     : has

 url: url
 word: word


chaining:
 # e.g. left chaining
 #  x , y , z
 #  (x , y) , z
 #  x , z
 #  x
 ","  : left
 ":"  : left

default_chain: right


opposites:
# or will you trip over your bootstraps into the rabbit hole of defining the properties of the semantics within the syntax itself?
# "opposite" is a relation, naturally an edge. the edges "->" and "<-" should have the "opposites" edge between them.


properties:
 # with graphical interpretation
 - symmetric #: directed => undirected
 - transitive #: in/out edge => path to/from

relations:
 # nice abuse of notation with colon

 related: symmetric
 similar: symmetric

 iff: symmetric, transitive
 equals: symmetric, transitive

 causes: transitive
 implies: transitive
 subset: transitive

 alias: transitive
